### Process Control Block

CPU는 한 번에 하나의 연산만 수행한다. CPU는 여러 개의 프로세스를 동시에 실행하지 않고, 빠르게 번갈아가며 실행한다. 

운영체제는 PCB를 만들어 관리하고, 필요한 정보들이 저장된다. PID, 레지스터 데이터, 스케줄링 정보, 상태 등

### 프로세스 상태

생성 -> 준비 <-> 실행 -> 대기 -> 종료 or 다시 준비

### 컨텍스트 스위칭

프로세스 A가 실행중이고, 프로세스 B가 준비 상태에서 B로 스위칭하면 레지스터에 A 의 데이터가 메모리에 저장이 되고, 레지스터에는 B의 데이터가 저장이 된다.

### 프로세스 생성

프로그램 실행 시 운영체제는 코드 영역과 데이터 영역을 메인 메모리에 올리고 빈 스택, 빈 힙을 만들어 공간을 확보합니다.

새로운 프로세스를 생성하는 것보다, 기존 프로세스를 복사하는 것이 더 빠릅니다. 따라서 **모든 프로세스는 최초의 프로세스로부터 복사**됩니다.

fork() 시스템 함수를 사용함. 이는 사용자가 커널에 직접 접근하지 않아 안전한 방법입니다.

그 다음, exec() 시스템 함수를 사용하여, 코드 영역과 데이터 영역을 원하는 내용으로 덮어쓰는 작업을 해줍니다.

### 스레드

컨텍스트 스위칭으로 인한 부하를 줄이기 위해서는 프로세스를 줄여야합니다. 프로세스는 스레드를 만들어서 작업을 나눌 수 있습니다.

스레드는 스레드가 하나 생성될 때마다 스레드를 위한 스택 영역이 추가로 생성될 뿐, 그 이외의 영역은 프로세스 영역을 공유합니다.

스레드는 프로세스가 처리해야 할 작업을 수행하기 위해 존재하는 것이므로, 코드 영역을 공유해 명령어에 접근할 수 있어야한다. 명령어가 실행 시 전역변수 정적변수 지역변수 등의 데이터에 접근해야 하므로 데이터 영역과 힙 영역도 공유해야 한다.

### 프로세스 스케줄링

CPU는 여러 개의 프로세스를 빠르게 번갈아 실행하기 위해, 각 프로세스를 위해 일하는 시간을 조금씩 나누어 배분한다. 그런데 이때 어떤 기준을 가질까요?

#### 프로세스 우선순위

누구에게 CPU를 할당해 줄것인가, 얼마동안 할당해 줄것인가? 이런 방법이 많고, 또 각 프로세스에게는 우선순위라는 것이 존재하기 때문에 이를 고려해야한다. 또 우선순위가 같은 프로세스들의 처리도 해야함

운영체제는 준비 상태의 프로세스와 대기 상태의 프로세스를 관리하기 위해 큐를 사용합니다. 준비큐, 대기큐가 있다고합니다 내부에는 PCB가 있슴니다. 만약 우선순위가 높은 큐가 들어오면 순서를 앞에 배치합니다.

#### 스케줄링 알고리즘

적용 시, 고려사항이 있다.

- 부하가 최소화되어야 한다
- 컴퓨팅 자원을 효율적으로 사용해야 한다
- 균형잡힌 스케줄링을 해야한다
- 대기 및 응답시간이 너무 길어서는 안 된다

종류로는, 선입선출, 최단작업우선, 라운드로빈, 우선순위 스케줄링 등이 있습니다.


- FIFO: 단순하고 직관적이지만, 실행시간이 짧은 프로세스가 실행 시간이 긴 프로세스 뒤에서 한참 기다리는 상황이 발생할 수 있다.
- 최단작업우선: 단순하고 직관적이지만, 실행시간을 정확히 예측할 수 없다는 문제가 있어서 현실적이지 않습니다.
- 라운드로빈: 정해진 시간 만큼만 CPU를 점유하고, 시간이 다 지나면 컨텍스트 스위칭하는 방식.
- 우선순위 스케줄링: 앞선 알고리즘들의 기반이 되는 아이디어입니다. 우선순위만 고려할 경우 우선순위가 낮은 프로세스가 배제되어 버리는 '기아'상태에 빠질 수 있습니다.

### IPC 프로세스간 통신

프로세스는 독립적으로 실행되지만, 필요시 다른 프로세스와 데이터를 주고받으며 통신하는 경우도 있다. 이를 가리켜 프로세스간 통신이라한다.

통신을 하려면, 토잇ㄴ의 각 주체가 만날 수 있는 일종의 창구가 필요하다. 프로세스 간 통신에서도 마찬가지이다

#### 메일슬롯, 파이프

메일슬롯 방식의 IPC는 데이터를 받기 위해서 프로세스가 우체통 역할을 하는 객체를 마련하고 이를 통해 데이터를 주고 받는 방식.

파이프 방식의 IPC는 익명 파이프 또는 네임드 파이프를 이용해 데이터를 주고 받습니다. 익명 파이프는 서로 관계가 있는 프로세스 간에 통신을 할때 사용하는 단방향 파이프이고, 네임드 파이프는 프로세스 간에 양방향 통신을 할때 사용하는 파이프입니다.

### 동기화

프로세스들은 서로 독립적이지만, 프로세스간 통신을 하거나 같은 대상에 대한 작업을 함으로써 협력할 수 있다. 그런데 이때, 동시다발적으로 작업을 처리하면 문제가 발생할 수 있다

#### 공유자원과 임계구역

프로세스 간 통신에서는 공동으로 이용하는 변수가 파일, 입출력 기기등이 존재한다. 이를 가리켜 '공유자원'이라 한다. 공유자원은 각 프로세스의 접근 순선에 따라 결과가 달라질 수 있는데, 프로세스가 동시에 실행할 경우 문제가 발생할 수 있는 영역을 가리켜 '임계영역'이라 한다.

#### 상호배제

동기화 기법은 임계구역에서 발생할 수 있는 문제를 해결하기 위한 기법이다. 동기화 기법 구현시에는 '상호배제'라는 조건을 만족시켜야한다.

상호배제란, 하나의 프로세스가 임계구역에 들어갔다면 다른 프로세스는 임계구역에 들어갈 수 없다는 조건을 뜻한다.

#### 뮤텍스 락

화장실으로 예시를 든다면, 저희는 화장실 문이 잠겨있는걸 확인하고 기다리다가 사용가능해지면 들어가서 볼일을 봅니다. 이 동작과 마찬가지로 흘러간다고 생각하믄 됩니다.

- acquire: 프로세스가 임계구역에 진입하기전에 호출하는 문 잠그기 함수.
- release: 일을 마치고 나올때 잠금을 해제하는 함수 라고보면됩니다

#### 세마포어

위와 비슷하지만 공유자원이 여러개일때도 사용이 가능합니다. 열쇠라고 보시믄 됩니다.

사용할 공유자원의 열쇠가 없는 프로세스는 사용 못합니다.

- wait: 프로세스가 들어갈 수 있는지, 기다려야하는지를 알려주는 함수
- signal: 임계구역 앞에서 기다리는 프로세스에게 들어가도 된다고 알려주는 함수


### 식사하는 철학자

동시성과 교착상태를 설명하는 예시로, 여러 프로세스가 동시에 돌아갈 때 교착상태가 나타나는 원인을 직관적으로 알 수 있다.

다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 포크가 하나씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 이때 철학자가 스파게티를 먹기 위해서는 양 옆의 포크를 동시에 들어야 한다. 이때 각각의 철학자가 왼쪽의 포크를 들고 그 다음 오른쪽의 포크를 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자는 동시에 왼쪽의 포크를 들 수 있으나 오른쪽의 포크는 이미 가져가진 상태이기 때문에 다섯 명 모두가 무한정 서로를 기다리는 교착 상태에 빠지게 될 수 있다.

또 동시에 양쪽 포크를 집을 수 없어 식사를 하지 못하는 기아상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

해결책으로는 왼쪽 포크들을 f1~f5라 하고, P5 인 철학자를 제외한 네명은 먼저 fn을 집은 후에 fn+1 을 집는 방식을 취한다. 그리고 P5는 이와 반대로 f1을 먼저 집고, f5를 집는다면 원래 방식의 대칭성을 제거하여 교착상태를 막을 수 있다.

이 방법이 위의 철학자 문제에서는 쉽게 적용이 되지만, 실제로 적용하기에는 자원의 의존관계라던지, 순서를 정하는 문제등이 있어서 구현난이도가 매우 높다고한다. Application Level의 특수한 상황에서는 적용해볼법도하다.