## 소스코드, 명령어

```c
#include <stdio.h>

int main() {
    printf("hello~");
    return 0;
}
```

위 같은 코드는 컴퓨터가 못알아먹는다. 컴퓨터가 알게끔 번역해줘야함.

- 고급언어: 개발자가 이해하기 쉽게 만든 언어
- 저급언어: 컴퓨터가 이해하고 실행하는 언어, 기계어(0과 1로 이루어진) 어셈블리어 2가지가 존재함

어셈블리어는 기계어를 읽기 편한 형태로 번역한 저급 언어.

고급언어가 저급언어로 번역되는 방법엔 크게 컴파일, 인터프리트 방법이 있다.

소스코드 -> 컴파일(컴파일러에 의해) -> 목적코드(저급언어)

인터프리터 언어는 인터프리터에 의해 한 줄씩 실행한다. 컴파일언어는 첨부터 끝까지 확인하고 실행함. 그래서 인터프리터 언어는 소스코드 전체가 저급언어로 변환되기까지 기다릴 필요 x.

따라서 컴파일 언어는 오류가 도중에 발생하면 전체가 실행되지 않지만, 인터프리터 언어는 오류 발생 전까지는 실행가능

### 명령어 구조

저급 언어들은 명령어들로 이루어져있다는데, 어떻게 생겼을까

더해라 100과 120을, 빼라 메모리 32번지 안의 값과 33번지 안의 값을, 저장해라 10을 메모리 128번지에 등등 이런식의 형태를 가지고 있음

이를 연산코드와 오퍼랜드로 구성되어있다고 부름

- 오퍼랜드: 연산에 사용될 데이터 or 사용될 데이터가 저장된 위치(주소필드 라고 부르기도함) 오퍼랜드가 없는경우도 있고 1개 이상인 경우도 있다.
- 연산 코드: 데이터 전송, 산술/논리 연산, 제어흐름 변경, 입출력 제어의 명령을함.

대표적인 연산 코드 종류를 간단히 살펴보면,

- 데이터전송: Move, store, load(fetch, 메모리에서 cpu로 데이터를 가져와라), push, pop
- 산술/논리: add, subtract,multiply, increment,decrement,and,or,not,compare ...
- 제어흐름변경: jump, conditional jump, halt, call, return
- 입출력제어: read, write, start io, test io ...

> 오퍼랜드에 데이터를 바로 넣지 않고 주소를 사용하는 이유 ? 명령어의 크기가 제한되기 때문임. 명령어가 16비트이고 연산코드가 4비트라고 하면 12비트로 나눠서 표현해야하는데 2개의 오퍼랜드라면 64개밖에 표현이 x. 따라서 메모리 주소를 저장한다면 더 큰 값들을 표현이 가능하다. 

- 유효주소: 연산에 사용될 데이터가 저장된 위치
- 명령어 주소 지정방식(addressing modes)
  - 연산에 사용할 데이터가 저장된 위치를 찾는 방법
  - 유효주소를 찾는 방법
  - 다양한 명령어 주소 지정 방식들

### 명령어 주소 지정 방식

- 즉시 주소 지정 방식
  - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
  - 가장 간단함.
  - 데이터의 크기가 제한되지만, 빠르다

- 직접 주소 지정 방식
  - 오퍼랜드 필드에 유효주소 직접적으로 명시
  - 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어든다

- 간접 주소 지정방식
  - 오퍼랜드 필드에 유효주소의 주소를 명시
  - 앞의 방식들 보다 느림

- 레지스터 주소 지정 방식
  - 연산에 사용할 데이터가 저장된 레지스터 명시
  - 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름

- 레지스터 간접 주소 지정 방식
  - 연산에 사용할 데이터를 메모리에 저장. 
  - 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시 (레지스터 -> 메모리)