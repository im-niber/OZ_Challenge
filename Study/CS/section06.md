이번 섹션에는 메모리에 대해 알아봄

## RAM 종류

### DRAM Dynamic RAM

- 저장된 데이터가 동적으로 사라지는 RAM
- 데이터 소멸을 막기 위해 주기적으로 재활성화해야한다
- 일반적으로 메모리로 사용되는 RAM
  - 상대적으로 소비전력이 낮고 저렴하고 집적도가 높아 대용량 설계가 용이하기 때문

### SRAM Static RAM

- 저장된 데이터가 사라지지 않는 RAM
- DRAM 보다 일반적으로 더 빠름
- 일반적으로 캐시 메모리에서 사용되는 RAM
  - 상대적으로 소비전력이 높고 가격이 높고 집적도가 낮아 대용량 설계가 필요없으나 빨라야 하는 장치에 사용

### SDRAM Synchronous DRAM

- 특별한 (발전된 형태의) DRAM
- 클럭 신호와 동기화된 DRAM

### DDR SDRAM Double Data Rate SDRAM

- 특별한 (발전된 형태의) SDRAM 
- 최근 가장 대중적으로 사용하는 RAM
- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
  - 대역폭은 데이터를 주고받는 길의 너비.

> DDR2는 DDR의 두 배임. SDRAM 보다 무 려 4배
> DDR3, DDR4도 있다 ~

## 메모리 주소 공간

논리주소? 물리주소 ? 이렇게 나눈 이유? 논리주소를 물리주소로 변환하는 방법 ?

먼저, CPU와 실행중인 프로그램이 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알고 있을가요 ? no

그 이유로는, 메모리에 저장된 값들은 시시각각 변하기 때문임니다. 새롭게 실행되는 프로그램은 새롭게 메모리에 적재, 실행이 끝난 프로그램은 메모리에서 삭제, 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소는 달라짐니다

이렇게 변하는 주소를 캧이 하기 위해서 논리주소가 필요한듯하네요.

### 물리주소

- 메모리 입장에서 바라본 주소
- 말 그대로 정보가 실제로 저장된 하드웨어상의 주소

### 논리주소

- CPU와 실행중인 프로그램 입장에서 바라본 주소
- 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소 (ex, 인터넷 논리주소 0번지 할당, 게임 프로그램의 0번지부터 할당 ... )

### 물리주소와 논리 주소의 변환

MMU(메모리 관리 장치)라는 하드웨어에 의해 변환 CPU -> 논리주소 -  MMU - 물리주소 -> 메모리

MMU는 논리주소와 베이스레지스터(프로그램의 기준주소)값을 더하여 논리주소를 물리 주소로 변환함 

### 메모리보호 - 한계 레지스터

- 프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음
- 베이스 레지스터가 실행중인 프로그램의 가장 작은 물리주소를 저장한다면 한계 레지스터는 논리주소의 최대 크기를 저장
- 베이스 레지스터 값 <= 프로그램 물리 주소 범위 < 베이스 레지스터 + 한계 레지스터 값

> CPU가 받아들이는 모든 주소는 논리주소이다.

## 캐시메모리

먼저, CPU가 메모리에 접근하는 시간은 CPU 연산 속도보다 느립니다.

캐시메모리란

- CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반 저장장치
- CPU 연산 속도와 메모리 접근속도 차이를 조금이나마 줄이기 위해 탄생
- CPU가 매번 메모리에 왔다 갔다 하는 건 시간이 오래 걸리니, 메모리에서 CPU가 사용할 일부 ㄴ데이터를 미리 캐시 메모리로가지고 와서 쓰자 라는 취지에서 나옴

### 계층적 캐시 메모리 L1, L2, L3

L1 캐시와 L2 캐시는 일반적으로 코어 내부에, L3 캐시는 코어 외부에 위치한 경우가 많습니다.

멀티코어 프로세서의 캐시 메모리의 경우, L1, L2는 각 코어마다 존재하고, L3는 공유해서 사용하는 경우가 많다고함.

하지만 문제점으로는 각 코어마다 캐시메모리가 있기 때문에 데이터를 통일하기 위해 싱크를 맞춰야 하는 문제가 있다.

#### 분리형 캐시

캐시 메모리를 더욱 빠르게 사용하기 위해, 명령어만 담는 캐시메모리, L1i 데이터만 담는 캐시 메모리 L1D 로 나누는 분리형 캐시 메모리도 존재한다.

### 참조 지역성의 원리

캐시 메모리는 메모리보다 용량이 작슴니다. 당연하게도 메모리의 모든 내용을 저장할 수 없습니다. 그렇다면 어떤 걸 저장해야 할까요? -> CPU 가 자주 사용할 법한 내용을 예측하여 저장합니다.

이 예측이 성공한다면 이를 **캐시 히트** 라고 합니다.

실패한다면 **캐시 미스**라고 합니다. 

최대한 캐시 미스가 일어나지 않도록 해야겠죠.

이때 CPU가 사용할 법한 데이터를 예측하는 방법에서 참조 지역성의 원리를 활용합니다.

이 원리는 CPU가 메모리에 접근할 때의 주된 경향성을 바탕으로 만들어진 원리입니다.

- CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있습니다.
- CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있습니다.

첫번째 원리를 코드로 살펴보면 다음과 같습니다.

```c
int main(void) {
    int num = 2;

    for(int i=1; i<= 9; i++) 
        printf("%d * %d = %d\n", num, i, num * i);

    return 0;
}
```

위 코드는 num 주소 공간에 계속해서 접근하고 있음을 알 수 있습니다.

두번째 원리는 **공간 지역성**이라고도 합니다. 보통 메모리 내부에 프로그램이 할당되면 해당 프로그램 영역에 관련된 데이터, 기능들이 다 모여있기 때문이져. 이런 경향성으로 인해, 두 번째 원리가 나왔다는것을 알 수 있슴니다.