요번 섹션에서는 ALU, 레지스터 등에 대해서 알아보는 섹션

ALU는 계산하는 장치. 제어장치는 제어 신호를 발생시키고 명령어를 해석하는 장치

ALU, 제어장치가 내보내고 받아들이는 정보들에 대해서 살펴보려고 한다

## ALU

ALU가 받아들이는 것들은 제어장치의 제어신호, 레지스터들의 피연산자들이 있고 내보내는 것들에는 플래그 레지스터에 플래그를 내보내거나, 레지스터로 결과값을 내보낸다.

계산을 하기 위해서는 피연산자와 수행할 연산이 필요하다. 그런 측면에서 필요한 정보들을 받아들이고 있다~

> 메모리로 가지않고 레지스터에 담는 이유? cpu 입장에서는 레지스터로 접근하는것이 더 효율적이기 떄문

플래그란 연산결과에 대한 부가정보이다. 예시로는 2진수를 음수, 양수로 표현할때 사용하는 예시가 있다. 값이 음수, 0, 오버플로우 같은 상황이라면 이에 대한정보를 플래그에 담아서 보낸다.

### 플래그의 종류

- 부호: 연산한 결과의 부호를 나타냄.
- 제로: 0인지 여부
- 캐리: 연산 결과 올림수나 빌림수가 발생했는지
- 오버플로우: 오버플로우 여부
- 인터럽트: 인터럽트가 가능한지 여부
- 슈퍼바이저: 커널모드로 실행 중인지, 사용자 모드로 실행중인지 여부

위의 플래그들로 플래그 레지스터가 구성되어있다 ~

## 제어장치

제어장치가 받아들이는 것들은 플래그 레지스터의 플래그, 명령어 레지스터의 명령어, 제어 버스에서의 제어신호 그리고 클럭이 있다.

- 클럭: 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위

내보내는 것들로는 제어신호가 있다 이때 레지스터, alu, 메모리, 입출력장치로 내보낸다.

---

## 레지스터

레지스터는 CPU 내부의 작은 임시저장장치, 프로그램 속 명령어 & 데이터는 실행 전후로 레지스터에 저장

레지스터 여러개가 CPU 내부에 있고, 여러 종류의 레지스터가 있다.

### 레지스터 종류. 반드시 알아야할

- 프로그램 카운터: 메모리에서 가져올 명령어의 주소(메모리에서 읽어들인 명령어의 주소)
- 명령어 레지스터: 해석할 명령어를 저장함. (방금 메모리에서 읽어 들인 명령어,  제어장치가 해석)
- 메모리 주소 레지스터: 메모리의 주소를 저장함, CPU가 읽어 들이고자 하는 주소를 주소 버스로 보낼 때 거치는 레지스터
- 메모리 버퍼 레지스터: 메모리와 주고 받을 값(데이터와 명령어)를 저장함. CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터
  
예를 들어, 메모리 1000 번 주소 내부에 1101번 명령어가 있다고 하면 프로그램 카운터에서는 1000번지의 메모리를 읽으려고 하기 때문에 1000번지 메모리 주소가 저장된다. 

그리고 나서 이를 메모리 주소 레지스터에 저장해야, 읽을거라는 제어신호를 주소버스를 통해서 보낼 수 있기 때문에 메모리 주소 레지스터에 복사됩니다.

그리고 메모리한테 몇 번지 주소를 읽고싶은지 주소버스를 통해 전달함. 그러면 메모리는 데이터 버스를 통해 1000번지 내부 명령어의 주소를 메모리 버퍼 레지스터로 전달합니다. 이 때 프로그램 카운터는 1 증가하는데 이것의 이유로는 다음 실행할 명령어의 주소를 나타내기 위해서 이다.

> PC가 1 증가하면, 다음 메모리 주소를 자연스럽게 나타내게 되는데 이런 프로그램이 순차적으로 실행되는 원리가 된다. 하지만 무조건 1 증가 하지는 않음.
> 
> 특정 메모리 주소로 실행 흐름을 이동하는 명령어(jump, conditional jump, call, ret) 인터럽트 발생 등등 이런 경우 상황에 맞는 명령어 주소가 담기게 된다.

이제 들고온 명령어를 해석하기 위해 메모리 버퍼 레지스터에 있는 명령어를 명령어 레지스터에 복사합니다.

- 플래그 레지스터: 연산 결과 또는 CPU 상태에 대한 부가적인 정보
- 범용 레지스터: 다양하고 일반적인 상황에서 자유롭게 사용
- 스택 포인터: 주소 지정에 사용
- 베이스 레지스터: 주소 지정에 사용

#### 특정 레지스터를 이용한 주소 지정방식

- 스택 주소 지정 방식: 스택과 스택 포인터를 이용한 주소 지정 방식, 스택포인터? 스택의 꼭대기를 가리키는 레지스터. 스택이 어디까지 차 있는지에 대한 표시

> 이때 스택은 메모리 내부에 있슴니다. 스택 영역이라고 하는 곳에 존재함니다

- 변위 주소 지정 방식: 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효주소를 얻는 방식, 간단하게 피연산자 + 특정 레지스터 값을 더해서 주소를 얻음.

이 방식에서는 명령어 내부에 어떤 레지스터 값과 더할지도 표현해야함.

프로그램 카운터, 베이스 레지스터를 더해서 유효주소를 얻는 방식이 주로 있다.

프로그램 카운터를 사용하는 방식은 상대 주소 지정 방식이라고 부름.

예를 들어, 명령어 내부에 연산코드 | 프로그램 카운터 | -3  이렇게 구성되어 있다면, 유효주소는 프로그램 카운터 주소에서 -3 번지를 나타내게 된다. 따라서 상대적이다 ~

베이스 레지스터 방식은 베이스 레지스터 내부 값이 기준 주소가 된다. 

## 명령어 사이클과 인터럽트

- 명령어 사이클: 프로그램 속 명령어들이 일정한 주기가 반복되며 실행되는 것

먼저, 메모리에 저장된 명령어를 실행하는경우에 사이클을 살펴보겠슴니다.

메모리 내부 명령어를 CPU로 갖고 오는 과정을 인출이라고 하고, 이 주기를 인출 사이클이라고 합니다.

그리고 나서는 실행해야겠져. 이 실행하는 주기를 실행사이클이라고 함니다. 

하지만 cpu로 명령어를 가지고 와도 바로 실행이 불가능한 경우도 존재합니다. 명령어 내부 오퍼랜드가 유효주소의 주소를 나타내는 경우가 대표적임니다. 이런 경우에는, 또 인출해야 하므로 추가적인 사이클을 두는데 이를 간접 사이클이라고 합니다. 

이러한 정해진 흐름을 끊는게 **인터럽트** 이다.

### 인터럽트

CPU가 얼른 처리해야 할 다른 작업이 생겼을 때 발생한다. 이상한 일에 발생하면 너무 비효율적이겠져

- 동기 인터럽트(예외): CPU가 예기치 못한 상황을 접했을 때 발생
  - 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있다
- 비동기 인터럽트(하드웨어 인터럽트): 주로 입출력 장치에 의해 발생, 알림과 같은 역할. 예를 들어서 프린터가 인쇄가 끝나면 cpu 한테 완료가 되었다고 알림을 보내서 인터럽트를 발생시키는 예시가 있다. 키보드, 마우스의 인터럽트도 요기에 해당된다

하드웨어 인터럽트는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 사용한다. 알림과 같은 인터럽트

입출력 장치는 CPU에 비해 느림. 인터럽트가 없다면 프린트 완료 여부를 확인하기 위해 주기적으로 확인해야함 -> 비효율. 인터럽트가 있다면 cpu는 그동안 다른 일을 할 수 있다.

#### 하드웨어 인터럽트 순서

1. 입출력장치는 cpu에 인터럽트 요청 신호를 보낸다.
2. cpu는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함
3. cpu는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함
4. 인터럽트를 받아 들일 수 있다면 cpu는 지금까지의 작업을 백업함 
5. cpu는 인터럽트 벡터 를 참조하여 인터럽트 서비스 루틴을 실행함
6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해 둔 작업을 복구하여 실행을 재개함

인터럽트 서비스 루틴? 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하기 위한 프로그램, "키보드가 요청을 보내면 이렇게 행동해야 한다" 같은 루틴이다. 이것도 프로그램이기 때문에 메모리에 저장되어 있다. 루틴마다 시작 주소가 다 다르겠져?

인터럽트 벡터? 각각의 인터럽트를 구분하기 위한 정보. 루틴의 시작주소를 가지고 있다.보통 인터럽트 요청 신호를 보낼때 벡터도 데이터버스를 통해서 같이 보냄

CPU가 인터럽트를 처리한다 -> 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다(인터럽트의 시작 주소는 인터럽트 벡터를 통해 알 수 있다) 라는 의미.

---

인터럽트가 발생하면 지금 레지스터에 저장되어 있는 값들은 어떻게 해야할가? 돌아가야하기 때문에 어딘가에 백업을 해야만한다. 이때 스택에 다 백업해둔다 ~

> 이제 명령어 사이클에서 살펴본 그림에서 인터럽트 사이클이 추가가된다면, 실행 사이클이 끝나고 나서 확인을 하고 발생하면, 인터럽트 사이클에서 인출사이클로 넘어간다.
>
> 간접 사이클은 인출 사이클에서 실행이 시작된다