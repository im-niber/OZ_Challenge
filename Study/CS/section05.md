요번 섹션에서는 CPU 관련해서 알아보는 섹션

먼저 알아둘 내용은

- 컴퓨터 부품들은 '클럭 신호' 에 맞춰 움직임
- CPU는 '명령어 사이클'이라는 정해진 흐름에 맞춰 명령어를 실행함

이런 배경지식을 바탕으로 CPU를 빠르게 설계하려면 클럭 신호를 빠르게 반복하면 성능이 늘어날것으로 기대할 수 있다.

하지만 실제로는 꼭 그렇지만은 않다. 일반적으로는 yes

## 클럭 속도

- 헤르츠 단위로 측정
- 헤르츠: 1초에 클럭이 반복되는 횟수
  - 클럭이 1초에 한 번 반복되면 1Hz
  - 100번 반복되면 100Hz

intel i7 11700 cpu의 성능 스펙을 보면 1초에 기본적으로 25억번. 최대 49억번 반복된다고 한다.

속도를 계속해서 늘려서 성능을 향상시키면 좋겠지만 필요 이상으로 클럭을 높이면 발열이 심각해진다.

그러면 다른 방법으로 뭐가 있을까 ?
 
## 코어와 멀티코어

다른 방법 중에서 코어를 늘리거나 스레드 수를 늘리는 방법이 있다. 

### 코어?

명령어를 실행하는 부품 이라는 의미를 가진 단어를 코어라고 사용한다.

요즘 날에는 cpu 내부에 여러 코어가 존재함. 코어 내부는 alu, 레지스터, 제어장치가 존재한다 ~

---

그러면 코어 수에 비례해서 속도가 증가할까? 꼭 그렇지는 않다.

코어마다 적절하게 연산이 분배되어야만 속도가 증가한다.

### 스레드? 

실행 흐름의 단위. 

소프트웨어적인 스레드, 하드웨어적 스레드가 존재한다.

- 하드웨어 스레드: 하나의 코어가 동시에 처리하는 명령어 단위

- 소프트웨어 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위. 멀티 스레드의경우 하나의 프로그램에서 동시에 여러 개의 두개 이상의 영역이 실행되는걸 의미함. (이미지를 들고오는 스레드, 이미지를 화면에 보여주는 스레드 등등)

1코어 1스레드 cpu도 동시에 여러 개의 소프트웨어 스레드를 만들 수 있습니다. cpu는 내부적으로 엄청난 속도로 여러 작업을 시작하고 멈출 수 있기 때문에 사람의 눈으로는 동시에 실행되는것 처럼 보임니다.

---

다시 하드웨어 스레드로 넘어와서, 멀티 스레드 프로세서를 실제로 설계하는 일은 매우 복잡하지만, 가장 큰 핵심은 레지스터입니다

- 레지스터 세트: 하나의 명령어를 실행하기 위해 꼭 필요한 레지스터들을 편의상 해당 용어로 표기.

위의 레지스터 세트를 하나의 코어가 여러개를 들고 있다면, 동시에 여러 작업을 할 수 있슴니다. 프로그램 카운터 같은 중요 레지스터들도 여러 개가 있다는 의미이기 때문입니다.

하드웨어 스레드는 또 논리 프로세서라고도 부릅니다. 메모리에서 실행되는 작업 흐름들과 실제 프로세서 갯수는 다르기 때문에 요런식으로도 부름니다.

## 명령어 병렬 처리 기법

시간을 알뜰하게 사용하면서 명령어들을 처리할 방법에 대한 내용

### 명령어 파이프라인

1. 명령어 인출 (Instruction Fetch)
2. 명령어 해석 (Instruction Decode)
3. 명령어 실행 (Execute Instruction)
4. 결과 저장 (Write Back)

- 같은 단계가 겹치지만 않는다면 cpu는 각 단계를 동시에 실행할 수 있슴니다.

#### 파이프라인 위험? 

명령어 파이프라인이 성능향상에 실패하는 경우를 의미함.

- 데이터 위험: 명령어 간의 의존성에 의해 야기, 모든 명령어를 동시에 처리할 수 없다 (이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우)
  - 예를들어, 명령어 1: R1 <- R2 + R3. 명령어 2: R4 <- R1 + R5 라고 하면, 명령어 1이 끝나야 R1의 값이 확정나므로 명령어 2를 실행할 수 있다. 그러므로 동시에 실행이 불가하다


- 구조 위험: 서로 다른 명령어가 같은 cpu 부품(alu, 레지스터)를 쓰려고 할 때 발생


- 제어 위험: 프로그램 카운터의 갑작스러운 변화, 만약 명령어를 해석해서 다른 메모리 주소로 가야한다면 다음 명령어들의 의미가 없어진다. (보통 메모리에서 순차적으로 명령어를 들고 오기 때문, 보통 분기 예측을 해서 이런 경우를 방지한다고 함)

#### 슈퍼 스칼라

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조, 한 번에 두가지 명령어 인출하고 실행 가능하다면 2개씩 묶어서 실행하는 흐름으로 이루어짐. (오늘날의 멀티프로세서)

이론적으로 파이프라인 개수에 비례하여 처리 속도가 증가하지만, 위에서 살펴본 위험도의 증가로 인해 개수에 비례하여 처리 속도가 증가하지는 않는다

### 비순차적 명령어 처리

합법적인 새치기라고 보면된다.

지금까지 설명한 방식들은 모두 순차적으로 명령어를 처리하는 방식이었따. 하지만 순차적으로만 다 처리하는게 가능한 경우보다는 순서가 뒤죽박죽인게 많겠져.

또 위에서 살펴본 데이터 위험 측면에서 의존성이 있다면 동시에 실행하는게 불가한 경우도 있는데 비순차명령어처리 기법을 사용하면 의존성을 가진 명령어를 후순위로 미룰 수 있어서 효율적이겠져

하지만 아무 명령어의 순서를 바꿀순 업슴니다. 의존성이 없는 명령어만 바꿔야 프로그램에 영향이 없겠져

## 명령어 집합구조, CISC RISC

명령어 파이프라이닝을 하기에 유리하게 생긴 명령어가 있고 아닌 명령어가 있슴니다. 이에대해 살펴보겠슴다

### 명령어 집 합

CPU는 명령어를 실행합니다. 하지만 모든 cpu가 똑같이 생긴 명령어를 실행할까요? ㄴㄴ cpu마다 보통 연산, 주소 지정 방식 등은 다 다름니다.

- 명령어 집합(구조): cpu가 이해할 수 있는 명령어들의 모음. 인텔 cpu 에서 만든 실행파일을 그대로 아이폰에 옮겨서 실행하면 실행 x

이런 관점에서 명령어 집합은 cpu의 언어 임니다.

명령어가 달라지면 모든게 달라지겠져 파이프라이닝, 레지스터 종류 개수, 명령어 해석 방식등등...

명령어 집합(Instruction Set Architecture)는 cpu의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속 입니다

이런 집합에서 가장 큰 카테고리인 CISC RISC에 대해서도 알아보겠슴니다.

### CISC Complex Instruction Set Computer

복잡한 명령어 집합을 활용하는 컴퓨터(cpu), x86, x86-64는 이 기반 명령어 집합 구조임니다.

말 그대로 복잡하고 다양한 명령어 활용하고, 명령어 형태와 크기가 다양한 가변 길이 명령어를 활용합니다. 그래서 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있슴니다.

메모리를 아끼면서 개발해야 했던 예전에 인기가 높았으나, 파이프라이닝이 불리하다는 치명적인 단점이 존재한다.

명령어의 크기와 실행되기전까지의 시간이 일정하지 않고, 복잡한 명령어 때문에 명령어 하나를 실행하는데 여러 클럭 주기가 필요하다.

### RISC Reduced Instruction Set Computer

명령어의 종류가 적고, 짧고 규격화된 명령어를 사용한다. 고정길이의 명령어를 활용하고, 1클럭 내외로 명령어를 수행함니다.

메모리 접근 최소화(load store), 레지스터 십분 활용 

다만 명령어 종류가 CISC 보다 적기 때문에 더 많은 명령어로 프로그램을 실행합니다